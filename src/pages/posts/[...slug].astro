---
import path from "node:path";
import License from "@components/misc/License.astro";
import Markdown from "@components/misc/Markdown.astro";
import I18nKey from "@i18n/i18nKey";
import { i18n } from "@i18n/translation";
import MainGridLayout from "@layouts/MainGridLayout.astro";
import { getSortedPosts } from "@utils/content-utils";
import { getDir, getPostUrlBySlug } from "@utils/url-utils";
import { Icon } from "astro-icon/components";
import { licenseConfig } from "src/config";
import ImageWrapper from "../../components/misc/ImageWrapper.astro";
import PostMetadata from "../../components/PostMeta.astro";
import { profileConfig, siteConfig } from "../../config";
import { formatDateToYYYYMMDD } from "../../utils/date-utils";

export async function getStaticPaths() {
    const blogEntries = await getSortedPosts();
    return blogEntries.map((entry) => ({
        params: { slug: entry.slug },
        props: { entry },
    }));
}

const { entry } = Astro.props;

const renderResult = await entry.render();
const { Content, headings } = renderResult;
const { remarkPluginFrontmatter } = renderResult;

const jsonLd = {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    headline: entry.data.title,
    description: entry.data.description || entry.data.title,
    keywords: entry.data.tags,
    image: entry.data.image
        ? new URL(
                entry.data.image.startsWith("/")
                    ? entry.data.image
                    : `/${entry.data.image}`,
                Astro.site,
            ).href
        : new URL("/og-default.png", Astro.site).href,
    author: {
        "@type": "Person",
        name: profileConfig.name,
        url: Astro.site?.toString(),
    },
    publisher: {
        "@type": "Person",
        name: profileConfig.name,
        url: Astro.site?.toString(),
    },
    datePublished: formatDateToYYYYMMDD(entry.data.published),
    dateModified: entry.data.updated
        ? formatDateToYYYYMMDD(entry.data.updated)
        : formatDateToYYYYMMDD(entry.data.published),
    mainEntityOfPage: {
        "@type": "WebPage",
        "@id": new URL(`/posts/${entry.slug}/`, Astro.site).href,
    },
    inLanguage: entry.data.lang
        ? entry.data.lang.replace("_", "-")
        : siteConfig.lang.replace("_", "-"),
};

const nextUrl = entry.data.nextSlug ? getPostUrlBySlug(entry.data.nextSlug) : null;
const prevUrl = entry.data.prevSlug ? getPostUrlBySlug(entry.data.prevSlug) : null;
---
<MainGridLayout 
    banner={entry.data.image} 
    title={entry.data.title} 
    description={entry.data.description} 
    lang={entry.data.lang} 
    setOGTypeArticle={true} 
    headings={headings}
>
    <script is:inline slot="head" type="application/ld+json" set:html={JSON.stringify(jsonLd)}></script>
    
    <article 
        class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative mb-4"
        itemscope 
        itemtype="https://schema.org/BlogPosting"
    >
        <div 
            id="post-container" 
            class:list={["card-base z-10 px-6 md:px-9 pt-6 pb-4 relative w-full", {}]}
        >
            <div 
                class="flex flex-row text-black/30 dark:text-white/30 gap-5 mb-3 transition onload-animation"
                role="complementary"
                aria-label="Información del artículo"
            >
                <div class="flex flex-row items-center">
                    <div 
                        class="transition h-6 w-6 rounded-md bg-black/5 dark:bg-white/10 text-black/50 dark:text-white/50 flex items-center justify-center mr-2"
                        aria-hidden="true"
                    >
                        <Icon name="material-symbols:notes-rounded"></Icon>
                    </div>
                    <div class="text-sm">
                        <span itemprop="wordCount">{remarkPluginFrontmatter.words}</span>
                        {" " + i18n(I18nKey.wordsCount)}
                    </div>
                </div>
                <div class="flex flex-row items-center">
                    <div 
                        class="transition h-6 w-6 rounded-md bg-black/5 dark:bg-white/10 text-black/50 dark:text-white/50 flex items-center justify-center mr-2"
                        aria-hidden="true"
                    >
                        <Icon name="material-symbols:schedule-outline-rounded"></Icon>
                    </div>
                    <div class="text-sm">
                        <span itemprop="timeRequired" content={`PT${remarkPluginFrontmatter.minutes}M`}>
                            {remarkPluginFrontmatter.minutes}
                        </span>
                        {" " + i18n(remarkPluginFrontmatter.minutes === 1 ? I18nKey.minuteCount : I18nKey.minutesCount)}
                    </div>
                </div>
            </div>

            <header class="relative onload-animation">
                <h1
                    data-pagefind-body 
                    data-pagefind-weight="10" 
                    data-pagefind-meta="title"
                    itemprop="headline"
                    class="transition w-full block font-bold mb-3
                    text-3xl md:text-[2.25rem]/[2.75rem]
                    text-black/90 dark:text-white/90
                    md:before:w-1 before:h-5 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-[0.75rem] before:left-[-1.125rem]
                ">
                    {entry.data.title}
                </h1>
            </header>

            <div class="onload-animation">
                <PostMetadata
                    class="mb-5"
                    published={entry.data.published}
                    updated={entry.data.updated}
                    tags={entry.data.tags}
                    category={entry.data.category}
                ></PostMetadata>
                {!entry.data.image && (
                    <div class="border-[var(--line-divider)] border-dashed border-b-[1px] mb-5"></div>
                )}
            </div>

            {entry.data.image && (
                <ImageWrapper 
                    id="post-cover" 
                    src={entry.data.image} 
                    basePath={path.join("content/posts/", getDir(entry.id))} 
                    class="mb-8 rounded-xl banner-container onload-animation"
                    itemprop="image"
                />
            )}

            <div itemprop="articleBody">
                <Markdown class="mb-6 markdown-content onload-animation">
                    <Content />
                </Markdown>
            </div>

            {licenseConfig.enable && (
                <License 
                    title={entry.data.title} 
                    slug={entry.slug} 
                    pubDate={entry.data.published} 
                    class="mb-6 rounded-xl license-container onload-animation"
                ></License>
            )}
        </div>
    </article>

    <nav 
        class="flex flex-col md:flex-row justify-between mb-4 gap-4 overflow-hidden w-full"
        aria-label="Navegación entre artículos"
    >
        {nextUrl ? (
            <a 
                href={nextUrl}
                class="w-full font-bold overflow-hidden active:scale-95 transition-transform"
                aria-label={`Anterior: ${entry.data.nextTitle}`}
                rel="prev"
            >
                <div class="btn-card rounded-2xl w-full h-[3.75rem] max-w-full px-4 flex items-center !justify-start gap-4">
                    <Icon 
                        name="material-symbols:chevron-left-rounded" 
                        class="text-[2rem] text-[var(--primary)] flex-shrink-0" 
                        aria-hidden="true"
                    />
                    <span class="overflow-hidden transition overflow-ellipsis whitespace-nowrap max-w-[calc(100%_-_3rem)] text-black/75 dark:text-white/75">
                        {entry.data.nextTitle}
                    </span>
                </div>
            </a>
        ) : (
            <div class="w-full" aria-hidden="true"></div>
        )}

        {prevUrl ? (
            <a 
                href={prevUrl}
                class="w-full font-bold overflow-hidden active:scale-95 transition-transform"
                aria-label={`Siguiente: ${entry.data.prevTitle}`}
                rel="next"
            >
                <div class="btn-card rounded-2xl w-full h-[3.75rem] max-w-full px-4 flex items-center !justify-end gap-4">
                    <span class="overflow-hidden transition overflow-ellipsis whitespace-nowrap max-w-[calc(100%_-_3rem)] text-black/75 dark:text-white/75">
                        {entry.data.prevTitle}
                    </span>
                    <Icon 
                        name="material-symbols:chevron-right-rounded" 
                        class="text-[2rem] text-[var(--primary)] flex-shrink-0" 
                        aria-hidden="true"
                    />
                </div>
            </a>
        ) : (
            <div class="w-full" aria-hidden="true"></div>
        )}
    </nav>

    <!--
        transition:name fuerza a Astro a tratar este contenedor como un
        elemento NUEVO en cada navegación en vez de hacer morphing del anterior.
        Sin esto, el iframe de Giscus de la página vieja sobrevive al swap
        y se muestra en la página nueva hasta que loadGiscus() lo reemplaza.
    -->
    <section 
        id="giscus-container"
        transition:name="giscus"
        transition:animate="none"
        class="card-base rounded-[var(--radius-large)] px-6 md:px-9 py-6 mt-6"
        aria-label="Comentarios del artículo"
    >
    </section>

    <script>
        // ============================================
        // GISCUS COMMENTS — ASTRO VIEW TRANSITIONS
        //
        // BUGS QUE HABÍA:
        //
        // 1. "Mantiene instancia vieja" (PC y móvil):
        //    Astro hace morphing de elementos con el mismo id entre páginas.
        //    El #giscus-container con su iframe sobrevivía al swap porque
        //    cleanup() nunca limpiaba su contenido. Se ve el contenido del
        //    post anterior mientras carga el nuevo.
        //    FIX → cleanup() hace container.innerHTML = '' inmediatamente,
        //    Y se añade transition:name="giscus" + transition:animate="none"
        //    en el HTML para que Astro no haga morphing del elemento.
        //
        // 2. "No carga en móvil al navegar":
        //    IntersectionObserver medía el contenedor durante la animación
        //    de View Transitions → layout inestable → nunca detectaba
        //    intersección en móvil (rendering más lento que en PC).
        //    FIX → tras navegación SPA, carga directa sin observer.
        //    El delay usa requestAnimationFrame x2 + 100ms extra en móvil
        //    en vez de un setTimeout fijo (más fiable que asumir duración
        //    de animación).
        // ============================================

        interface GiscusMessage {
            giscus: { setConfig: { theme: string } };
        }

        let giscusLoaded:         boolean = false;
        let isSpaNavigation:      boolean = false;
        let themeObserver:        MutationObserver | null = null;
        let intersectionObserver: IntersectionObserver | null = null;
        let iframeObserver:       MutationObserver | null = null;
        let resizeTimer:          number;
        let spaLoadTimer:         number;

        // ── Helpers ──────────────────────────────────────────────────────────

        function isMobile(): boolean {
            return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(
                navigator.userAgent.toLowerCase()
            ) || (window.innerWidth < 768 && navigator.maxTouchPoints > 0);
        }

        function currentTheme(): string {
            return document.documentElement.classList.contains('dark')
                ? 'transparent_dark' : 'light';
        }

        function getContainer(): HTMLElement | null {
            return document.getElementById('giscus-container');
        }

        // ── Esperar iframe de Giscus ──────────────────────────────────────────

        function waitForIframe(): Promise<HTMLIFrameElement | null> {
            return new Promise((resolve) => {
                const existing = document.querySelector<HTMLIFrameElement>('iframe.giscus-frame');
                if (existing) { resolve(existing); return; }

                const container = getContainer();
                if (!container) { resolve(null); return; }

                const timeout = window.setTimeout(() => {
                    iframeObserver?.disconnect();
                    iframeObserver = null;
                    resolve(null);
                }, 5000);

                iframeObserver = new MutationObserver(() => {
                    const iframe = document.querySelector<HTMLIFrameElement>('iframe.giscus-frame');
                    if (iframe) {
                        clearTimeout(timeout);
                        iframeObserver?.disconnect();
                        iframeObserver = null;
                        resolve(iframe);
                    }
                });

                iframeObserver.observe(container, { childList: true, subtree: true });
            });
        }

        // ── Observer de cambio de tema ────────────────────────────────────────

        function setupThemeObserver(): void {
            themeObserver?.disconnect();
            themeObserver = new MutationObserver((mutations) => {
                if (!mutations.some(m => m.attributeName === 'class')) return;
                const iframe = document.querySelector<HTMLIFrameElement>('iframe.giscus-frame');
                if (!iframe?.contentWindow) return;
                const msg: GiscusMessage = { giscus: { setConfig: { theme: currentTheme() } } };
                try {
                    iframe.contentWindow.postMessage(msg, 'https://giscus-personal-woft.vercel.app');
                } catch (e) {
                    console.error('[Giscus] Theme message error:', e);
                }
            });
            themeObserver.observe(document.documentElement, {
                attributes: true, attributeFilter: ['class']
            });
        }

        // ── Cargar Giscus ─────────────────────────────────────────────────────

        async function loadGiscus(): Promise<void> {
            if (giscusLoaded) return;

            const container = getContainer();
            if (!container) return;

            // Asegurarse de que el container esté vacío antes de inyectar
            // (por si el morphing dejó contenido residual)
            container.innerHTML = '';

            const script = document.createElement('script');
            script.src = 'https://giscus-personal-woft.vercel.app/es/client.js';
            script.setAttribute('data-repo',             'Cosmos20016/Gestion-de-comentarios');
            script.setAttribute('data-repo-id',          'R_kgDOPSHLmA');
            script.setAttribute('data-category',         'Announcements');
            script.setAttribute('data-category-id',      'DIC_kwDOPSHLmM4CtXsZ');
            script.setAttribute('data-mapping',          'pathname');
            script.setAttribute('data-strict',           '0');
            script.setAttribute('data-reactions-enabled','1');
            script.setAttribute('data-emit-metadata',    '0');
            script.setAttribute('data-input-position',   'bottom');
            script.setAttribute('data-theme',            currentTheme());
            script.setAttribute('data-lang',             'es');
            script.crossOrigin = 'anonymous';
            script.async = true;

            script.onerror = () => {
                container.innerHTML = `
                    <div class="flex flex-col items-center justify-center py-8 gap-3 text-red-500">
                        <span class="text-sm">Error al cargar comentarios</span>
                        <button onclick="location.reload()" class="text-xs underline hover:no-underline">
                            Recargar página
                        </button>
                    </div>`;
            };

            script.onload = async () => {
                giscusLoaded = true;
                const iframe = await waitForIframe();
                if (iframe) setupThemeObserver();
            };

            container.appendChild(script);
        }

        // ── Primera carga: IntersectionObserver con lazy load ─────────────────

        function isVisible(): boolean {
            const container = getContainer();
            if (!container) return false;
            const rect = container.getBoundingClientRect();
            return rect.top < (window.innerHeight ?? document.documentElement.clientHeight) + 200;
        }

        function initFirstLoad(): void {
            const container = getContainer();
            if (!container) return;

            if (isVisible()) { loadGiscus(); return; }

            intersectionObserver?.disconnect();
            intersectionObserver = new IntersectionObserver(
                (entries) => {
                    entries.forEach(e => {
                        if (e.isIntersecting && !giscusLoaded) {
                            loadGiscus();
                            intersectionObserver?.disconnect();
                        }
                    });
                },
                { rootMargin: isMobile() ? '400px' : '250px', threshold: 0 }
            );
            intersectionObserver.observe(container);
        }

        // ── Navegación SPA: carga directa sin IntersectionObserver ───────────
        //
        // FIX MÓVIL: usamos requestAnimationFrame x2 para esperar a que el
        // navegador haya pintado el nuevo layout. Más fiable que un setTimeout
        // fijo porque no asume ninguna duración de animación concreta.
        // En móvil añadimos 100ms extra por si el paint es más lento.

        function initAfterNavigation(): void {
            if (!getContainer()) return;
            clearTimeout(spaLoadTimer);

            const run = () => loadGiscus();

            if (isMobile()) {
                // rAF x2 + 100ms: espera 2 frames de paint + buffer para móvil
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        spaLoadTimer = window.setTimeout(run, 100);
                    });
                });
            } else {
                // rAF x2 es suficiente en desktop
                requestAnimationFrame(() => {
                    requestAnimationFrame(run);
                });
            }
        }

        // ── Cleanup ───────────────────────────────────────────────────────────

        function cleanup(): void {
            // FIX "instancia vieja": vaciar el contenedor AHORA, antes del swap.
            // Así el usuario nunca ve el iframe del post anterior en el nuevo.
            const container = getContainer();
            if (container) container.innerHTML = '';

            giscusLoaded    = false;
            isSpaNavigation = true;

            themeObserver?.disconnect();        themeObserver = null;
            intersectionObserver?.disconnect(); intersectionObserver = null;
            iframeObserver?.disconnect();       iframeObserver = null;

            clearTimeout(resizeTimer);
            clearTimeout(spaLoadTimer);
        }

        // ── Eventos Astro View Transitions ────────────────────────────────────

        document.addEventListener('astro:before-swap', cleanup);

        document.addEventListener('astro:page-load', () => {
            if (!getContainer()) return;

            if (isSpaNavigation) {
                initAfterNavigation();
            } else {
                initFirstLoad();
            }
        });

        // ── Re-check en resize / rotación ────────────────────────────────────

        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = window.setTimeout(() => {
                if (!giscusLoaded && isVisible()) loadGiscus();
            }, 500);
        });

        // ── Carga inicial (primera visita o recarga) ──────────────────────────

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initFirstLoad);
        } else {
            initFirstLoad();
        }
    </script>

    <style>
        #giscus-container {
            width: 100%;
            max-width: 100%;
            background: transparent !important;
            contain: layout;
            overflow: visible;
            min-height: 200px;
        }

        #giscus-container :global(iframe.giscus-frame) {
            width: 100% !important;
            max-width: 100% !important;
            min-height: 250px;
            border: none !important;
            background: transparent !important;
            display: block;
            contain: layout style paint;
            pointer-events: auto !important;
            touch-action: pan-y pan-x !important;
            -webkit-overflow-scrolling: touch;
        }

        :global(:not(.dark)) #giscus-container {
            background-color: var(--card-bg, white) !important;
        }

        :global(:not(.dark)) #giscus-container :global(iframe.giscus-frame) {
            color-scheme: light;
        }

        :global(.dark) #giscus-container {
            background-color: var(--card-bg, transparent) !important;
        }

        :global(.dark) #giscus-container :global(iframe.giscus-frame) {
            color-scheme: dark;
        }

        @media (max-width: 767px) {
            #giscus-container {
                padding: 1rem;
                border-radius: var(--radius-large);
                overflow: visible;
            }

            #giscus-container :global(iframe.giscus-frame) {
                min-height: 300px;
                position: relative;
                z-index: 1;
                isolation: isolate;
            }
        }

        @media (min-width: 768px) and (max-width: 1024px) {
            #giscus-container { padding: 1.5rem; }
            #giscus-container :global(iframe.giscus-frame) { min-height: 320px; }
        }

        @media (min-width: 1025px) {
            #giscus-container :global(iframe.giscus-frame) { min-height: 350px; }
        }

        @media (hover: none) and (pointer: coarse) {
            #giscus-container :global(button),
            #giscus-container :global(a),
            #giscus-container :global(input),
            #giscus-container :global(textarea) {
                min-height: 44px;
                min-width: 44px;
                padding: 0.75rem;
            }

            #giscus-container {
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
                overscroll-behavior: contain;
            }

            #giscus-container :global(input),
            #giscus-container :global(textarea) { font-size: 16px !important; }

            #giscus-container :global(iframe.giscus-frame) {
                touch-action: manipulation !important;
                user-select: text;
                -webkit-user-select: text;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            #giscus-container,
            #giscus-container * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        @media print {
            #giscus-container { display: none !important; }
        }

        #giscus-container :global(*) {
            max-width: 100%;
            box-sizing: border-box;
        }
    </style>

</MainGridLayout>
